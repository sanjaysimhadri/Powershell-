"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tl = require("azure-pipelines-task-lib/task");
const Q = require("q");
const webClient = require("./webClient");
const azure_arm_common_1 = require("./azure-arm-common");
const constants = require("./constants");
const fs = require("fs");
const path = require("path");
const certFilePath = path.join(tl.getVariable('Agent.TempDirectory'), 'spnCert.pem');
class AzureRMEndpoint {
    constructor(connectedServiceName) {
        // Add an entry here and separate function for each new environment
        this._environments = {
            'AzureStack': 'azurestack'
        };
        this._connectedServiceName = connectedServiceName;
        this.endpoint = null;
    }
    getEndpoint() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!!this.endpoint) {
                return this.endpoint;
            }
            else {
                this.endpoint = {
                    subscriptionID: tl.getEndpointDataParameter(this._connectedServiceName, 'subscriptionid', true),
                    subscriptionName: tl.getEndpointDataParameter(this._connectedServiceName, 'subscriptionname', true),
                    servicePrincipalClientID: tl.getEndpointAuthorizationParameter(this._connectedServiceName, 'serviceprincipalid', true),
                    environmentAuthorityUrl: tl.getEndpointDataParameter(this._connectedServiceName, 'environmentAuthorityUrl', true),
                    tenantID: tl.getEndpointAuthorizationParameter(this._connectedServiceName, 'tenantid', false),
                    url: tl.getEndpointUrl(this._connectedServiceName, true),
                    environment: tl.getEndpointDataParameter(this._connectedServiceName, 'environment', true),
                    scheme: tl.getEndpointAuthorizationScheme(this._connectedServiceName, true),
                    msiClientId: tl.getEndpointDataParameter(this._connectedServiceName, 'msiclientId', true),
                    activeDirectoryResourceID: tl.getEndpointDataParameter(this._connectedServiceName, 'activeDirectoryServiceEndpointResourceId', true),
                    azureKeyVaultServiceEndpointResourceId: tl.getEndpointDataParameter(this._connectedServiceName, 'AzureKeyVaultServiceEndpointResourceId', true),
                    azureKeyVaultDnsSuffix: tl.getEndpointDataParameter(this._connectedServiceName, 'AzureKeyVaultDnsSuffix', true),
                    scopeLevel: tl.getEndpointDataParameter(this._connectedServiceName, 'ScopeLevel', true),
                };
                this.endpoint.authenticationType = tl.getEndpointAuthorizationParameter(this._connectedServiceName, 'authenticationType', true);
                // if scheme is null, we assume the scheme to be ServicePrincipal
                let isServicePrincipalAuthenticationScheme = !this.endpoint.scheme || this.endpoint.scheme.toLowerCase() == constants.AzureRmEndpointAuthenticationScheme.ServicePrincipal;
                if (isServicePrincipalAuthenticationScheme) {
                    if (this.endpoint.authenticationType && this.endpoint.authenticationType == constants.AzureServicePrinicipalAuthentications.servicePrincipalCertificate) {
                        tl.debug('certificate spn endpoint');
                        this.endpoint.servicePrincipalCertificate = tl.getEndpointAuthorizationParameter(this._connectedServiceName, 'servicePrincipalCertificate', false);
                        this.endpoint.servicePrincipalCertificatePath = certFilePath;
                        fs.writeFileSync(this.endpoint.servicePrincipalCertificatePath, this.endpoint.servicePrincipalCertificate);
                    }
                    else {
                        tl.debug('credentials spn endpoint');
                        this.endpoint.servicePrincipalKey = tl.getEndpointAuthorizationParameter(this._connectedServiceName, 'serviceprincipalkey', false);
                    }
                }
                var isADFSEnabled = tl.getEndpointDataParameter(this._connectedServiceName, 'EnableAdfsAuthentication', true);
                this.endpoint.isADFSEnabled = isADFSEnabled && (isADFSEnabled.toLowerCase() == "true");
                if (!!this.endpoint.environment && this.endpoint.environment.toLowerCase() == this._environments.AzureStack) {
                    if (!this.endpoint.environmentAuthorityUrl || !this.endpoint.activeDirectoryResourceID) {
                        this.endpoint = yield this._updateAzureStackData(this.endpoint);
                    }
                }
                else {
                    this.endpoint.environmentAuthorityUrl = (!!this.endpoint.environmentAuthorityUrl) ? this.endpoint.environmentAuthorityUrl : "https://login.windows.net/";
                    this.endpoint.activeDirectoryResourceID = this.endpoint.url;
                }
                let access_token = tl.getEndpointAuthorizationParameter(this._connectedServiceName, "apitoken", true);
                this.endpoint.applicationTokenCredentials = new azure_arm_common_1.ApplicationTokenCredentials(this.endpoint.servicePrincipalClientID, this.endpoint.tenantID, this.endpoint.servicePrincipalKey, this.endpoint.url, this.endpoint.environmentAuthorityUrl, this.endpoint.activeDirectoryResourceID, !!this.endpoint.environment && this.endpoint.environment.toLowerCase() == constants.AzureEnvironments.AzureStack, this.endpoint.scheme, this.endpoint.msiClientId, this.endpoint.authenticationType, this.endpoint.servicePrincipalCertificatePath, this.endpoint.isADFSEnabled, access_token);
            }
            tl.debug(JSON.stringify(this.endpoint));
            return this.endpoint;
        });
    }
    _updateAzureStackData(endpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            let dataDeferred = Q.defer();
            let webRequest = new webClient.WebRequest();
            webRequest.uri = `${endpoint.url}metadata/endpoints?api-version=2015-01-01`;
            webRequest.method = 'GET';
            webRequest.headers = {
                'Content-Type': 'application/json'
            };
            let azureStackResult;
            try {
                let response = yield webClient.sendRequest(webRequest);
                if (response.statusCode != 200) {
                    tl.debug("Action: _updateAzureStackData, Response: " + JSON.stringify(response));
                    throw new Error(response.statusCode + ' ' + response.statusMessage);
                }
                azureStackResult = response.body;
            }
            catch (error) {
                throw new Error(tl.loc("FailedToFetchAzureStackDependencyData", error.toString()));
            }
            endpoint.graphEndpoint = azureStackResult.graphEndpoint;
            endpoint.galleryUrl = azureStackResult.galleryUrl;
            endpoint.portalEndpoint = azureStackResult.portalEndpoint;
            var authenticationData = azureStackResult.authentication;
            if (!!authenticationData) {
                var loginEndpoint = authenticationData.loginEndpoint;
                if (!!loginEndpoint) {
                    loginEndpoint += (loginEndpoint[loginEndpoint.length - 1] == "/") ? "" : "/";
                    endpoint.activeDirectoryAuthority = loginEndpoint;
                    endpoint.environmentAuthorityUrl = loginEndpoint;
                    endpoint.isADFSEnabled = loginEndpoint.endsWith('/adfs/');
                }
                else {
                    // change to login endpoint
                    throw new Error(tl.loc('UnableToFetchAuthorityURL'));
                }
                var audiences = authenticationData.audiences;
                if (audiences && audiences.length > 0) {
                    endpoint.activeDirectoryResourceID = audiences[0];
                }
                try {
                    var endpointUrl = endpoint.url;
                    endpointUrl += (endpointUrl[endpointUrl.length - 1] == "/") ? "" : "/";
                    var index = endpointUrl.indexOf('.');
                    var domain = endpointUrl.substring(index + 1);
                    domain = (domain.lastIndexOf("/") == domain.length - 1) ? domain.substring(0, domain.length - 1) : domain;
                    endpoint.azureKeyVaultDnsSuffix = ("vault." + domain).toLowerCase();
                    endpoint.azureKeyVaultServiceEndpointResourceId = ("https://vault." + domain).toLowerCase();
                }
                catch (error) {
                    throw new Error(tl.loc("SpecifiedAzureRmEndpointIsInvalid", endpointUrl));
                }
            }
            return endpoint;
        });
    }
}
exports.AzureRMEndpoint = AzureRMEndpoint;
function dispose() {
    if (tl.exist(certFilePath)) {
        tl.rmRF(certFilePath);
        tl.debug('Removed cert endpoint file');
    }
}
exports.dispose = dispose;
